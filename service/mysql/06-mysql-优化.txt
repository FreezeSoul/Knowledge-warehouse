

# 主键优化

表的主键表示您在最重要的查询中使用的一列或一组列。它有一个关联索引，用于快速查询性能。查询性能从NOT NULL优化中受益，因为它不能包含任何NULL值。通过InnoDB存储引擎，表格数据的物理组织可以进行超快速查找，并根据主键列进行排序。

如果您的表格很重要，但没有明显的列或一组列作为主键，那么您可以创建一个带有自动增量值的单独列作为主键。当您使用外键连接表时，这些唯一ID可用作指向其他表中相应行的指针。

# 外键优化

如果一个表有许多列，并且查询了许多不同的列组合，将不常用的数据拆分为每列有几列的单独表格，并通过复制数字ID将它们关联回主表可能很有效主表中的列。这样，每个小表可以有一个快速查找其数据的主键，并且可以使用连接操作仅查询需要的一组列。根据数据的分布情况，查询可能会执行较少的I / O并占用较少的缓存内存，因为相关列在磁盘上打包在一起。（为了最大限度提高性能，查询尝试从磁盘读取尽可能少的数据块;

# 高性能索引

大多数MySQL索引（PRIMARY KEY， UNIQUE，INDEX和 FULLTEXT）存储在 B树

## b-tree索引

没有指定特别的类型，那么多半就是b-tree索引

不是按照索引的最左列开始查找，则无法使用索引

不能跳过索引中间的列。如果不指定中间的索引，mysql只能使用索引的第一列

如果查询中有某个列的范围查找，则这列右边所有列都无法使用索引优化查找。

## 哈希索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。

哈希索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，哈希索引查找速度非常快

## 哈希索引限制

哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用哈希索引中的值来避免读取行，性能影响不大。

哈希索引数据并不是按照索引值顺序存储的，所以就无法用于排序。

哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如查询a，b列，a&b列建立了哈希索引，如果查询只有a列，则无法使用哈希索引。

select 'a'<=>'a'  结果1

select 'a'<=>'b'  结果0

哈希索引只支持等值比较查询，包括=、in（）、<=>也不支持任何范围查询。

哈希索引很快，除非有很多哈希冲突(不同的索引列值却有相同的哈希值)。

如果哈希冲突很多，索引维护代价高，删除表中一行，存储引擎需要遍历哈希值的链表每一行，找到并删除，冲突越多，代价越大

## 处理哈希冲突

使用哈希索引进行查询的时候，必须在where子句中包含常量值。

要避免冲突问题，必须在where条件中带入哈希值和对应列值。

索引的优点

b-tree索引，按照顺序存储数据，所以mysql可以用来做order by 和group by操作

索引大大减少了服务器需要扫描的数据量

索引可以帮助服务器避免排序和临时表

索引可以将随机i/o变为顺序i/o

对于中大型数据表，索引效率很高，对于特大型的表，建立和使用索引的代价变大，这时候就需要使用分区表。

## 高性能的索引策略

**独立的列**

查询不当使用索引，如查询中的列不是独立的，则mysql就不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。

**前缀索引和索引选择性**

**alter table table_name add key（字段名（前缀长度））**

前缀索引是一种使索引更小、更快的有效办法，mysql无法使用前缀索引做order by 和group by，也无法使用前缀索引做覆盖扫描

**多列索引**

**索引列顺序**

索引首先按照最左列进行排序，

选择性最高的列放在索引最前列。

例子：select *  from table where staff_id=2 and customer_id=584；

创建一个（staff_id,customer_id）索引还是应颠倒？可以跑一些查询来确定这个表中值的分布情况，来确定哪个列的选择性更高

select sum(staff_id=2) ,sum(customer_id=584) from table\G;

sum(staff_id=2) ：7992

sum(customer_id=584)：30

应该将索引列customer_id放在前面，因为对应条件值的customer_id数量更小、选择性更高。

**覆盖索引**

覆盖索引必须要存储索引列的值，而哈希索引、空间索引、和全文索引都不存储索引列的的值，mysql使用b-tree索引做覆盖索引。

使用索引扫描来做排序

## 多种过滤条件

通过in（）语句让mysql选择索引，这样写不会过滤任何行，和没有这个条件时返回的结果相同。但是必须加上这个列条件，mysql才能够匹配索引的最左前缀。(如果列有太多不同值就会让in（）过长这样做就不行）

但是where中每增加一个in（）条件，优化器需要做的组合都将指数增大，最终查询性能可能极大降低。

## 避免多个范围条件

对于范围条件查询，mysql无法再使用范围列后面的其他索引列了，但对于“多个等值条件查询”则没有限制

 

 

 

# 服务器环境8核32g内存（可能并不存在所谓最优的配置，服务器配置应该符合它的工作负载、数据、以及应用需求。）朋万mysql5.6.29；官方文档mysql5.6.6

mysql在线配置工具。<https://www.percona.com/>

生成事例：

主库：

\# Generated by Percona Configuration Wizard (http://tools.percona.com/) version REL5-20120208

\# Configuration name test-server generated for yuyumail1994@gmail.com at 2018-06-14 03:04:23

 

[mysql]

 

\# CLIENT #

port                           = 3306

socket                         = /data/mysql/data/mysql.sock

 

[mysqld]

 

\# GENERAL #

user                           = mysql

default-storage-engine         = InnoDB

socket                         = /data/mysql/data/mysql.sock

pid-file                       = /data/mysql/data/mysql.pid

 

\# MyISAM #

key-buffer-size                = 32M

myisam-recover-options         = FORCE,BACKUP

 

\# SAFETY #

max-allowed-packet             = 16M

max-connect-errors             = 1000000

skip-name-resolve

sql-mode                       = STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_AUTO_VALUE_ON_ZERO,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ONLY_FULL_GROUP_BY

sysdate-is-now                 = 1

innodb                         = FORCE

 

\# DATA STORAGE #

datadir                        = /data/mysql/data/

 

\# BINARY LOGGING #

log-bin                        = /data/mysql/data/mysql-bin

expire-logs-days               = 14

sync-binlog                    = 0    #0，1，2影响i/o性能选项

 

\# CACHES AND LIMITS #

tmp-table-size                 = 32M

max-heap-table-size            = 32M

query-cache-type               = 0

query-cache-size               = 0

max-connections                = 5000

thread-cache-size              = 256

open-files-limit               = 65535

table-definition-cache         = 4096

table-open-cache               = 10000

 

\# INNODB #

innodb-flush-method            = O_DIRECT

innodb-log-files-in-group      = 2

innodb-log-file-size           = 512M

innodb-flush-log-at-trx-commit = 2

innodb-file-per-table          = 1

innodb-buffer-pool-size        = 26G

 

\# LOGGING #

log-error                      = /data/mysql/data/mysql-error.log

log-queries-not-using-indexes  = 1

slow-query-log                 = 1

slow-query-log-file            = /data/mysql/data/mysql-slow.log

 

 

丛库：

\# Generated by Percona Configuration Wizard (http://tools.percona.com/) version REL5-20120208

\# Configuration name server generated for yuyumail1994@gmail.com at 2018-06-14 03:16:30

 

[mysql]

 

\# CLIENT #

port                           = 3306

socket                         = / var / lib / mysql /mysql.sock

 

[mysqld]

 

\# GENERAL #

user                           = mysql

default-storage-engine         = InnoDB

socket                         = / var / lib / mysql /mysql.sock

pid-file                       = / var / lib / mysql /mysql.pid

 

\# MyISAM #

key-buffer-size                = 32M

myisam-recover-options         = FORCE,BACKUP

 

\# SAFETY #

max-allowed-packet             = 16M

max-connect-errors             = 1000000

skip-name-resolve

sql-mode                       = STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_AUTO_VALUE_ON_ZERO,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ONLY_FULL_GROUP_BY

sysdate-is-now                 = 1

innodb                         = FORCE

 

\# DATA STORAGE #

datadir                        = / var / lib / mysql /

 

\# BINARY LOGGING #

log-bin                        = / var / lib / mysql /mysql-bin

expire-logs-days               = 14

sync-binlog                    = 1

 

\# REPLICATION #

read-only                      = 1

skip-slave-start               = 1

log-slave-updates              = 1

relay-log                      = / var / lib / mysql /relay-bin

slave-net-timeout              = 60

sync-master-info               = 1  #耐撞击吃性能

sync-relay-log                 = 1 #耐撞击

sync-relay-log-info            = 1 #耐撞击

 

\# CACHES AND LIMITS #

tmp-table-size                 = 32M

max-heap-table-size            = 32M

query-cache-type               = 0

query-cache-size               = 0

max-connections                = 5000

thread-cache-size              = 256

open-files-limit               = 65535

table-definition-cache         = 4096

table-open-cache               = 10000

 

\# INNODB #

innodb-flush-method            = O_DIRECT

innodb-log-files-in-group      = 2

innodb-log-file-size           = 512M

innodb-flush-log-at-trx-commit = 2 #影响i/o性能选项

innodb-file-per-table          = 1

innodb-buffer-pool-size        = 26G

 

\# LOGGING #

log-error                      = / var / lib / mysql /mysql-error.log

log-queries-not-using-indexes  = 1

slow-query-log                 = 1

slow-query-log-file            = / var / lib / mysql /mysql-slow.log

 

 

# mysql提示符配置：

prompt="\\u@\\h:\\d \\r:\\m:\\s>"

# mysql引擎设置：

show engines;

 

# mysql连接数配置：

根据线上业务量进行配置，show status ; 查看mysql状态

![clipboard.png](cid:clip_image002.jpg)

 

![clipboard.png](cid:clip_image004.jpg)

show variables；查看mysql配置参数。

![clipboard.png](cid:clip_image006.jpg)

(朋万的体量线上业务5000最大连接数足矣)

每个连接占用256kb

## Threads_connected  当前的连接数

## Connections  试图连接到(不管是否成功)MySQL服务器的连接数。

## Max_used_connections  服务器启动后已经同时使用的连接的最大数量。

## max_connections =5000 

## # MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过'conn%'通配符查看当前状态的连接数量，以定夺该值的大小。朋万值5000

## max_connect_errors = 100000

\# 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。

这个选项设置小了很容易导致问题，如果服务器可以充分抵抗蛮力攻击，可以把这个值设置的非常大。

## back_log设置:

\* 修改back_log参数值:由默认的50修改为500.（每个连接256kb, 占用：125M）

​     back_log=500

​     查看mysql 当前系统默认back_log值，命令：

​     show variables like 'back_log';

​     back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。将会报：

unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时.

​     back_log值不能超过TCP/IP连接的侦听队列的大小。若超过则无效，查看当前系统的TCP/IP连接的侦听队列的大小命令：cat /proc/sys/net/ipv4/tcp_max_syn_backlog，目前系统为1024。对于Linux系统推荐设置为大于512的整数。

修改系统内核参数，可以编辑/etc/sysctl.conf去调整它。如：net.ipv4.tcp_max_syn_backlog = 2048，改完后执行sysctl -p 让修改立即生效。

## open_files_limit = 65535

\# MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，

 

 

# 缓存和内存设置优化设置：

## 全局缓存：

数据库属于IO密集型的应用程序，其主职责就是数据的管理及存储工作。而我们知道，从内存中读取一个数据库的时间是微秒级别，而从一块普通硬盘上读取一个 IO是在毫秒级别，二者相差3个数量级。所以，要优化数据库，首先第一步需要优化的就是IO，尽可能将磁盘IO转化为内存IO。本文先从MySQL数据库 IO相关参数(缓存参数)的角度来看看可以通过哪些参数进行IO优化

 

## max_allowed_packet =16M

\# 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。

\# 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。

## binlog_cache_size = 4M

\# 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K

## thread_cache_size = 256

线程缓存

\# 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，

\# 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，

\# 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–>表示要调整的值)

\# 根据物理内存设置规则如下：

\# 1G  —> 8

\# 2G  —> 16

\# 3G  —> 32

\# 大于3G  —> 64

一个连接256K，通常应该保证线程缓存足够大，避免threads_create频繁增长，如果这个数字过大，可能需要把thread_cache_size 调小一些，因为并不能很好地处理庞大的线程数，其中大部分是休眠的。

## table_open_cache=10000

table_cache是一个非常重要的MySQL性能参数，它在5.1.3之后的版本中叫做table_open_cache。table_cache主要用于设置table高速缓存的数量。由于每个客户端连接都会至少访问一个表，因此此参数的值与max_connections有关。

缓存机制

\# MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64，一些资料推荐把这个数值设置为（max_connections* 查询同时用到的表数）。我实践中发现，一般设置为max_connections就没问题了（如果还不够，可以继续加大，但不能设置大得离谱，可能会引发其他问题）。

如果opened_tables状态变量很大或者在增长，可能因为表缓存不够大，可以适当增加。如果设置过大会导致关机时间变慢。

不应该超过10240

\#有些类型的工作负载是不能缓存的：如果有几万张表或几十万张表，并且它们都很均匀地被使用，就不可能全部缓存了。建议设置为max_connections的10倍

**max_heap_table_size = 64M**

\# 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变,

## tmp_table_size=64M

max_heap_table_size和tmp_table_size上两个设置控制使用memory引擎的内存临时表能使用多大内存，这两个值应该保持一致

\#tmp_table_size 控制内存临时表的最大值,超过限值后就往硬盘写,如果动态页面要调大点，100M以上，如果网站大部分都是静态内容，一般64M足够,你做很多高级 GROUP BY 查询，增加 tmp_table_size 值。

\# MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。

\# 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。

\# 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果

## query_cache_size = 0

以上信息是默认配置，其注释意思是说，MYSQL的查询缓存用于缓存select查询结果，并在下次接收到同样的查询请求时，不再执行实际查询处理而直接返回结果，有这样的查询缓存能提高查询的速度，使查询性能得到优化，前提条件是你有大量的相同或相似的查询，而很少改变表里的数据，否则没有必要使用此功能。可以通过Qcache_lowmem_prunes变量的值来检查是否当前的值满足你目前系统的负载。注意：如果你查询的表更新比较频繁，而且很少有相同的查询，最好不要使用查询缓存。

## query_cache_type = 0

这个变量有三个取值：0,1,2，分别代表了off、on、demand。

mysql默认为开启 on

## query_cache_limit = 2M

\#指定单个查询能够使用的缓冲区大小，默认1M(query_cache_size = 0,关闭后配置无效)，如果查询结果大于这个值，则不会被缓存

## key_buffer_size = 8M

​    key_buffer_size是用于索引块的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，对MyISAM(MySQL表存储的一种类型，可以百度等查看详情)表性能影响最大的一个参数。如果你使它太大，系统将开始换页并且真的变慢了。严格说是它决定了数据库索引处理的速度，尤其是索引读的速度。对于内存在4GB左右的服务器该参数可设置为256M或384M.

 

怎么才能知道key_buffer_size的设置是否合理呢，一般可以检查状态值Key_read_requests和Key_reads   ，比例key_reads / key_read_requests应该尽可能的低，比如1:100，1:1000 ，1:10000。其值可以用以下命令查得：show status like 'key_read%';

 

比如查看系统当前key_read和key_read_request值为：

 

+-------------------+-------+

 

| Variable_name     | Value |

 

+-------------------+-------+

 

| Key_read_requests | 28535 |

 

| Key_reads         | 269   |

 

+-------------------+-------+

 

可知道有28535个请求，有269个请求在内存中没有找到直接从硬盘读取索引.

未命中缓存的概率为：0.94%=269/28535*100%.  一般未命中概率在0.1之下比较好。目前已远远大于0.1，证明效果不好。若命中率在0.01以下，则建议适当的修改key_buffer_size值。

key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。

对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M）

http://dbahacker.com/mysql/innodb-myisam-compare(InnoDB与MyISAM的六大区别)

http://kb.cnblogs.com/page/99810/（查看存储引擎介绍）

MyISAM、InnoDB、MyISAM Merge引擎、InnoDB、memory(heap)、archive

 

 

## 局部缓存：

除了全局缓冲，MySql还会为每个连接发放连接缓冲。个连接到MySQL服务器的线程都需要有自己的缓冲。大概需要立刻分配256K，甚至在线程空闲时，它们使用默认的线程堆栈，网络缓存等。事务开始之后，则需要增加更多的空间。运行较小的查询可能仅给指定的线程增加少量的内存消耗，然而如果对数据表做复杂的操作例如扫描、排序或者需要临时表，则需分配大约read_buffer_size，

sort_buffer_size，read_rnd_buffer_size，tmp_table_size 大小的内存空间. 不过它们只是在需要的时候才分配，并且在那些操作做完之后就释放了。有的是立刻分配成单独的组块。tmp_table_size 可能高达MySQL所能分配给这个操作的最大内存空间了。注意，这里需要考虑的不只有一点——可能会分配多个同一种类型的缓存，例如用来处理子查询。一些特殊的查询的内存使用量可能更大——如果在MyISAM表上做成批的插入

时需要分配 bulk_insert_buffer_size 大小的内存；执行 ALTER TABLE， OPTIMIZE TABLE， REPAIR TABLE 命令时需要分配 myisam_sort_buffer_size 大小的内存。

##  

## read_buffer_size = 2M

\# MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。

\# 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能

## read_rnd_buffer_size = 16M

\# MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，

\# MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大

## sort_buffer_size = 2M（可以全局也可以局部）

\# MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。

\# 如果不能，可以尝试增加sort_buffer_size变量的大小

## join_buffer_size =4M（可以全局可以局部）

\# 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享,最后需要注意的是，每一个线程都会创建自己独立的buffer而不是整个系统共享，所以设置的值过大会造成系统内存不足

##  

# innodb优化：

改变innodb执行i/o操作可以显著地影响性能。

## innodb_buffer_pool_size=24106M

## innodb_buffer_pool_instances=8（or 1 if innodb_buffer_pool_size < 1GB）

对于缓冲池在数GB范围内的系统，通过在不同线程读取和写入缓存页面时减少争用，将缓冲池划分为不同的实例可以提高并发性。此功能通常用于缓冲池大小在数GB范围内的系统。使用innodb_buffer_pool_instances 配置选项配置多个缓冲池实例 ，并且您也可以调整该 innodb_buffer_pool_size值。

当InnoDB缓冲池很大时，通过从内存中检索可以满足许多数据请求。您可能会遇到来自尝试一次访问缓冲池的多个线程的瓶颈。您可以启用多个缓冲池以最大限度地减少此争用。存储在缓冲池中或从中读取的每个页面都使用散列函数随机分配给其中一个缓冲池。每个缓冲池管理自己的空闲列表，刷新列表，LRU以及连接到缓冲池的所有其他数据结构，并受其自己的缓冲池互斥锁保护。

要启用多个缓冲池实例，请将innodb_buffer_pool_instances配置选项设置为 大于1（默认值）最大为64（最大值5.66以下版本最大8）的值。此选项只有在您设置innodb_buffer_pool_size为1GB或更大的大小时才会生效 。您指定的总大小被分配到所有缓冲池中。为了获得最佳效率，指定的组合 innodb_buffer_pool_instances 和innodb_buffer_pool_size，使得每个缓冲池实例是至少为1GB。

## innodb_io_capacity = 300（默认200）

该innodb_io_capacity 参数设置InnoDB后台任务每秒执行的I / O操作数的上限，例如刷新缓冲池中的 页面以及合并来自更改缓冲区的数据 。

innodb_io_capacity应设置为大约系统每秒可执行的I / O操作数。理想情况下，保持尽可能低的设置，但不要太低以至于背景活动落后。如果该值太高，则数据将从缓冲池中删除，并且插入缓冲区太快而无法进行缓存以提供显着的优势。

对于较低端的SSD，默认设置为200通常就足够了。例如，对于更高端的总线连接的SSD，考虑更高的设置，例如1000。对于具有单个5400 RPM或7200 RPM驱动器的系统，您可能会将该值降低到100，这代表可以执行大约100 IOPS的旧一代磁盘驱动器可用的每秒I / O操作（IOPS）的估计比例。

尽管您可以指定一个非常高的值，例如100万，但实际上，这样大的值几乎没有好处。通常，建议不要使用20000或更高的值，除非您已经证明较低的值不足以满足您的工作负载。

## innodb_read_io_threads=8（默认4）

## innodb_read_write_threads=8（默认4）

## innodb_old_blocks_time （默认1000）

## 变量指定一个页面从lru链表的年轻部分转移到年老部分之前必须经过的毫秒数

## innodb_log_file_size = 512M

在每个字节大小日志文件在日志组。日志文件（innodb_log_file_size* innodb_log_files_in_group）的组合大小不能超过略小于512GB的最大值。例如，一对255 GB的日志文件接近极限，但不超过它。默认值是48MB。

通常，日志文件的组合大小应该足够大，以便服务器可以消除工作负载活动中的高峰和低谷，这通常意味着有足够的重做日志空间来处理一个多小时的写入活动。值越大，缓冲池中所需的检查点刷新活动就越少，从而节省磁盘I / O。较大的日志文件也会使崩溃恢复速度变慢，尽管对MySQL 5.5和更高版本中的恢复性能的改进使得日志文件的大小更小。

 

innodb_log_files_in_group = 3

innodb_log_buffer_size = 64M

## innodb_flush_log_at_trx_commit = 2 # 0,2,1

N=0    每隔一秒，把事务日志缓存区的数据写到日志文件中，以及把日志文件的数据刷新到磁盘上；

   log buffer 会 每秒写入到日志文件并刷写（flush）到磁盘。但每次事务提交不会有任何影响，也就是 log buffer 的刷写操作和事务提交操作没有关系。在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失。

   

N=1    每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上； 

​    当取值为 1 时，每次事务提交时，log buffer 会被写入到日志文件并刷写到磁盘。这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢。

 

N=2    每事务提交的时候，把事务日志数据从缓存区写到日志文件中；每隔一秒，刷新一次日志文件，但不一定刷新到磁盘上，而是取决于操作系统的调度； 

​    当取值为 2 时，每次事务提交会写入日志文件，但并不会立即刷写到磁盘，日志文件会每秒刷写一次到磁盘。这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。 

上面说到的「最后 1s」并不是绝对的，有的时候会丢失 更多数据。有时候由于调度的问题，每秒刷写（once-per-second flushing）并不能保证 100% 执行。对于一些数据一致性和完整性要求不高的应用，配置为 2 就足够了；如果为了最高性能，可以设置为 0。有些应用，如支付服务，对一致性和完整性要求很高，所以即使最慢，也最好设置为 1. 

​      当我们设置为2 的时候，Log Thread 会在我们每次事务结束的时候将数据写入事务日志，但是这里的写入仅仅是调用了文件系统的文件写入操作。而我们的文件系统都是有缓存机制的，所以Log Thread 的这个写入并不能保证内容真的已经写入到物理磁盘上面完成持久化的动作。文件系统什么时候会将缓存中的这个数据同步到物理磁盘文件Log Thread 就完全不知道了。所以，当设置为2 的时候，MySQL Crash 并不会造成数据的丢失，但是OS Crash 或者是主机断电后可能丢失的数据量就完全控制在文件系统上了。各种文件系统对于自己缓存的刷新机制各不一样，大家可以自行参阅相关的手册。

 

innodb_flush_method = O_DIRECT

innodb_data_file_path = ibdata1:1G:autoextend

如果表空间损坏，innodb会拒绝启动，回收空间唯一的方式是导出数据，关闭mysql，删除所有文件，修改配置，重启，让innodb创建新数据文件。

innodb_file_per_table=1

选项让innodb为每一张表使用一个文件。

innodb_doublewrite=1

开启双写缓冲，丛库可上可以禁止双写缓冲。

# i/o优化：

## sync_binlog=0

默认关闭，设置1，崩溃后mysql会把事务日志和二进制日志分开刷新到两个不同的位置，保障了安全，但是对性能损失大。

# 推荐配置sync_binlog&innodb_flush_log_at_trx_commit 组合： 

N=1,1  — 适合数据安全性要求非常高，而且磁盘IO写能力足够支持业务，比如充值消费系统； 

N=1,0  — 适合数据安全性要求高，磁盘IO写能力支持业务不富余，允许备库落后或无复制； 

N=2,0或2,m(0<m<100)  — 适合数据安全性有要求，允许丢失一点事务日志，复制架构的延迟也能接受； 

N=0,0  — 磁盘IO写能力有限，无复制或允许复制延迟稍微长点能接受，例如：日志性登记业务； 

  当两个参数设置为双1的时候，写入性能最差，sync_binlog=N (N>1 ) innodb_flush_log_at_trx_commit=2 时，(在当前模式下)MySQL的写操作才能达到最高性能。 

数据安全性

当innodb_flush_log_at_trx_commit和sync_binlog  都为1时是最安全的，在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句或者一个事务。但是鱼与熊掌不可兼得，都为1会导致频繁的IO操作，因此该模式也是最慢的一种方式。 

当innodb_flush_log_at_trx_commit设置为0，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。 

当innodb_flush_log_at_trx_commit设置为2，只有在操作系统崩溃或者系统掉电的情况下，上一秒钟所有事务数据才可能丢失。 

双1适合数据安全性要求非常高，而且磁盘IO写能力足够支持业务，比如订单,交易,充值,支付消费系统。双1模式下，当磁盘IO无法满足业务需求时，推荐的做法是innodb_flush_log_at_trx_commit=2 ，sync_binlog=N (N为500 或1000) 且使用带蓄电池后备电源的缓存cache，防止系统断电异常。

# 安全和稳定设置

## expire_logs_days=14

启用二进制日志，后可以打开，可以让服务器清理指定天数之后清理旧的二进制日志。

## max_allowed_packet=16M

这个设置防止服务器发送太大的包，也会控制多大的包可以被接受，如果设置太小，通常表现为备库不能接受主库发送过来的复制数据。建议16M或者更大。

## skip-name-resolve禁止mysql对外部进行DNS解析：

\# 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，

\# 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求

\#关闭dns查找，如果dns出问题，会导致堆积，最终超时。

## sql_mode=NO_ENGINE_SUBSTITUTION

一类是所谓的宽松无敌模式（my.ini中sql_mode设置为空或仅NO_ENGINE_SUBSTITUTION）, 这种模式下，not null 的字段，在insert或update时不设置值也能成功，db在插入时，会自动给默认值，比如int会给0值，甚至可以把abc赋值给int型的字段（当然，db会自动忽略该值，变成默认值0）

如果使用mysql，为了继续保留大家使用oracle的习惯，可以对mysql的sql_mode设置如下：

在my.cnf添加如下配置

[mysqld]

sql_mode='ONLY_FULL_GROUP_BY,NO_AUTO_VALUE_ON_ZERO,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,

ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,PIPES_AS_CONCAT,ANSI_QUOTES'

## read_only=OFF

这个选项禁止没有特权的用户在备库做变更，只接受从主库传输过来的变更。

## skip_slave_start

阻止mysql自动启动复制。

## slave_net_timeout=60

slave_net_timeout 默认为1小时，设置为1分钟或者更短

 

# sync_relay_log_info&sync_master_info &sync_relay_log 这几个选项设置可能会导致同步延迟非常严重。

## master_info_repository=TABLE（默认）

这个变量是在MySQL 5.6.2中添加的。

## sync_master_info =10000 （默认）

这个变量对复制从机的影响取决于从机是否 master_info_repository被设置为FILE或TABLE，如下面的段落所述。

master_info_repository = FILE。  如果值sync_master_info大于0，那么在每次事件之后，从站会将其master.info文件同步 到磁盘（使用 fdatasync()） sync_master_info。如果它是0，则MySQL服务器不会将master.info文件同步 到磁盘; 相反，服务器依靠操作系统定期刷新其内容，与其他文件一样。

master_info_repository = TABLE。  如果值sync_master_info大于0，那么从设备在每次sync_master_info事件之后都会更新其主信息存储库表 。如果它是0，表从不更新。

默认值sync_master_info是从MySQL 5.6.6开始的10000，在此之前为0。

## sync_relay_log =10000 （默认）

如果此变量的值大于0，那么MySQL服务器将fdatasync()每个sync_relay_log事件写入中继日志后，将其中继日志同步到磁盘（正在使用 ） 。

设置sync_relay_log为0不会导致同步到磁盘; 在这种情况下，服务器依赖于操作系统随时刷新中继日志的内容，就像其他文件一样。

在MySQL 5.6.6之前，0是这个变量的默认值。在MySQL 5.6中。之后，默认值为10000。

值为1是最安全的选择，因为在发生崩溃时，您最多会从中继日志中丢失一个事件。但是，它也是最慢的选择（除非磁盘有电池支持的缓存，这使得同步非常快）

## sync_relay_log_info=10000 （默认）

 

sync_relay_log_info = 0

如果 relay_log_info_repository 设置为FILE，则MySQL服务器不会将relay-log.info文件同步 到磁盘; 相反，服务器依靠操作系统定期刷新其内容，与其他文件一样。

 

如果 relay_log_info_repository 设置为TABLE，并且该表的存储引擎是事务性的，则在每次事务后更新表。（sync_relay_log_info在这种情况下， 设置被有效忽略。）

 

如果 relay_log_info_repository 设置为TABLE，并且该表的存储引擎不是事务性的，则该表永远不会更新。

 

sync_relay_log_info = N > 0

如果 relay_log_info_repository 设置为FILE，则从机在每次事务处理后将其relay-log.info文件同步 到磁盘（使用fdatasync()） N。

 

如果 relay_log_info_repository 设置为TABLE，并且该表的存储引擎是事务性的，则在每次事务后更新表。（sync_relay_log_info在这种情况下， 设置被有效忽略。）

 

如果 relay_log_info_repository 设置为TABLE，并且该表的存储引擎不是事务性的，则在每个N事件之后更新表 。

# 操作系统和硬件优化

## cpu选择

 

## 随机i/o和顺序i/o

随机i/o从缓存中收益最多。

顺序访问内存行的速度也快于随机访问。内存随机访问比磁盘随机访问快乐2500倍，而内存顺序访问只有磁盘的10倍速度。

增加内存是解决随机i/o读取最好的办法。

## 缓存，读和写

多次写入，一次刷新

i/o合并

## 工作集是什么

完成工作不需要办公桌里的每一张纸一样，也不需要把整个数据库装到内存中来获得最佳性能——只需要工作集就可以。

应该依据最常用的页面集来考虑工作集,而不是最频繁读写的页面集.

工作集包括数据和索引

innodb做一个单行查找需要读取磁盘，就需要把包含改行的整个页面读入缓冲池进行缓存，

如果要随机访问100字节的行。每一行都必须读取和缓存一个完整的16kb页面，因为工作集也包括索引，innodb也会读取并缓存查找行所需的索引树的一部分。innodb的索引页大小也是16kb，意味着访问一个100字节的行为可能一共要使用32kb的缓存空间（或者更多）。聚集索引不仅可以优化磁盘访问，还可以帮助同一页面存储相关的数据。

## 内存/磁盘比例

缓存未命中是当查询请求数据时,数据不能在内存中命中,服务器需要从磁盘获取数据

缓存命中率高,也决定了cpu使用高,等待i/o的时间越少。

有大量小的磁盘随机读写考虑因素:

奇技淫巧:更大容量的单碟磁盘,然后只使用20%~30%的容量.增加了数据局部性和减少寻道时间.

存储容量：

传输速度：

访问时间：通常这个是主要因素

主轴转速：磁盘转速对顺序查找和随机查找都有很大影响

物理尺寸：2.5英寸的磁盘性能比大磁盘更好

需要更快的磁盘

 

## RAID性能优化：

raid 0 成本低性能最高，没有冗余，损坏概率更高    写快  N

raid 1 高速读，简单，安全   写不快  盘数少通常2个盘

raid 5 安全（速度）成本折中   依赖于最慢的盘 N+1

raid 10 昂贵，高速，安全   写快    2N

raid 50 为极大的数据存储服务   写快    2（N+1）

## 网络配置

禁用DNS查找 **skip_name_resolve**

TCP积压  back_log调大 默认50不够用，如果不够大客户端会看到连接被拒绝。 在liunx系统中 **vim /proc/sys/net/core/somaxconn** 限制默认只有128 增加到262144，**net.ipv4.tcp_max_syn_backlog**  设置为26214 

'tcp_max_syn_backlog'变量告诉你的盒子有多少SYN请求保留在内存中，我们还没有从3次握手中获得第三个数据包。 tcp_max_syn_backlog变量被'tcp_syncookies'变量覆盖，该变量需要被打开才能起作用。 如果服务器在高峰时段遭受过载，则可能需要稍微增加此值。

改变本地端口范围，调整的大一点

**/proc/sys/net/ipv4/ip_local_port_range**

1024 65535

## 选择文件系统

**windows（ntfs）**

**linux（使用日志文件系统ext3、ext4、xfs、zfs、jfs）推荐xfs**

**选择磁盘队列调度策略**

cat /sys/block/sda/queue/scheduler 

这里sda可以替换成想看的任何盘符

3)**Deadline**(截止时间调度程序)

特点:

通过时间以及硬盘区域进行分类,这个分类和合并要求类似于noop的调度程序.

Deadline确保了在一个截止时间内服务请求,这个截止时间是可调整的,而默认读期限短于写期限.这样就防止了写操作因为不能被读取而饿死的现象.

Deadline对数据库环境(**ORACLE RAC,MYSQL**等)是最好的选择.

## 内存交换区

绝对不能让系统虚拟内存溢出，如果交换空间溢出时，liunx内核都会完全hang住。

cat /proc/sys/vm/swappiness 

服务器应该设置为0

innodb_flush_method=0_DIRECT

减轻服务器i/o压力

## 操作系统状态

**iostat和vmstat**

**vmstat**

**procs**

**r这一列显示了多少进程正在等待CPU，b列显示多少进程正在不可中断地休眠（通常意味着他们在等待i/o，例如磁盘、网络、用户输入、等）**

**memory**

**swpd列显示多少块被换出到了磁盘（页面交换）。剩下的三个列显示了多少块是空闲的、多少块正在被用作缓冲，以及多少正在被用作操作系统的缓存**

**swap**

**这些列显示页面交换活动：每秒有多少块正在被换入（从磁盘）和换出（到磁盘）。它们比监控swpd列重要多了。**

**大部分时间我们喜欢看到si和so列是0，并且不希望看到每秒超过10个块。**

**io**

**这些列显示有多少块从快设备读取（bi）和写出（bo）。反映了磁盘i/o**

**system**

**这些列显示了每秒中断和上下文切换的数量**

**cpu**

**这些列显示了所有的cpu时间花费在各类操作的百分比，.**

**内存、交换区、以及i/o统计是块数而不是字节数。**

**一个块1024字节**

 

 

关闭selinux

 

 

 

 

 