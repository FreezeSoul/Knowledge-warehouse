第一章

整个 MySQL 程序包括客户端和服务端，客户端和服务端通过网络进行通信。当某个客户端和服务端建立连接后，就会在服务器进程中拥有一个线程。使用线程池可以避免频繁地创建和销毁线程。

MySQL 会将一条查询语句解析成内部数据结构——解析树，然后对其进行优化：重写查询、决定表的读取顺序、选择合适的索引等。对于 Select 语句，会用整个查询语句作为 Key，去缓存中查询处理结果。

关于并发控制。MySQL 会在两个层面来进行：服务器层、存储引擎层。最经典的解决方案就是锁机制，它通过两种类型的锁组成锁系统：共享锁（读锁）、排它锁（写锁）。锁的粒度会决定系统的并发度。一种提高共享资源的并发性的方法就是让锁更具有选择性，即只锁定需要修改的部分数据，而不是所有。在给定的资源上，锁定的数据量越少，则系统的并发程度越高。


另一方面，关于锁的操作：获得锁、检查锁是否解决、释放锁等都会增加系统的开销。因此锁策略就是在锁的开销和数据的安全性之间寻求平衡，既保证数据并发安全又能提高数据库的性能。各种数据库系统一般都是实现的行级锁。MySQL 的存储引擎可以实现自己的锁策略和锁粒度。

表锁是 MySQL 中开销最小、最基本的锁策略。尽管存储引擎可以管理自己的锁，但在执行诸如 Alter table 之类的语句时，服务器会忽略存储引擎的锁，而直接用表锁。

行级锁可以最大程度地支持并发处理，同时也带来了最大的锁开销。行级锁只在存储引擎中实现，服务器层没有实现，行级锁对服务器是透明的。


事务：ACID
原子性	事务不可分割
一致性	从一个一致性状态到另一个一致性状态，及时在事务执行过程中崩溃。
隔离性	事务之间的隔离，参考隔离级别。
持久性	事务提交后的数据持久保存

  隔离级别：
    read uncommitted 未提交读  未提交对其他事务可读， 脏读， 一般不用。
    read committed   提交读（不可重复读）  只能看到已经提交的数据， 大多数数据库的默认级别，MySQL不是。
	也叫做不可重复读，因为重复执行相同的查询会得到不同的结果。
    repeatable read  可重复度  保证了在同一事务中多次读取的一致性。
	无法解决幻读的问题： 事务A第一次访问数据 --> 数据a , 事务B修改数据 将数据a -->数据库a， 事务A第二次访问数据 --> 数据a（此时的数据应该是b，产生幻读）。
	通过MVCC（多版本的并发控制）解决幻读。
    serializable    串行化   最高隔离级别 事务强行串行。高一致性 无并发。



死锁：
多个事务不同顺序锁定同一资源，以下是死锁的例子：
事务1
	更新行1
	更新行2
事务2
	更新行2
	更新行1

死锁发生后，只有部分或完全回滚其中一个事务，才能打破死锁。InnoDB 目前处理死锁的方法就是将持有最少行级排他锁的事务进行回滚。死锁的发生还和存储引擎的实现有关。

事务日志：
内存数据库修改 --> 事务日志
            --> 后台慢慢写入数据表
存储引擎在修改数据表时，只需要先修改表的内存拷贝，再通过事务日志将所做的修改顺序追加到磁盘上的事务日志中，而对数据表的修改可以在后台慢慢地刷回磁盘，这样提高了事务的执行效率。这种实现方式称为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。 

MySQL 中的事务：
MySQL 提供了两种支持事务的存储引擎：InnoDB 和 NDB Cluster；比较知名的第三方的存储引擎，如 XtraDB 和 PBXT 也支持事务。

MySQL 默认采用自动提交模式，即如果不显示地开始一个事务，则每个查询都被当作一个事务执行提交操作。一些会导致大量数据改变的操作，如 Alter Table，Lock Tables（在服务层实现，和存储引擎无关） 等语句，在执行之前，会强制执行 commit 提交当前的活动事务。

MySQL 服务器层不管理事务，由底层的存储引擎实现事务。在同一个事务中，使用多种存储引擎是不可靠的。例如，在一个事务中混用了事务型和非事务型的表，非事务型表无法完成回滚操作，会导致数据库处于不一致的状态。

Lock Tables 和 UnLock Tables 语句是在服务器层实现的，有自己的用途，不能代替事务处理。


多版本并发控制（MVCC）：

关于 MVCC。它是行级锁的一个变种，在很多情况下避免了锁操作，因此开销更低。因为 MVCC 并没有一个统一的实现标准，所以不同库的实现机制有所不同，但都实现了非阻塞的读操作，写操作也只是锁定必要的行。

MVCC 是通过保存数据在某个时间点的快照来实现的。不管事务执行多长时间，在一个事务中，它看到的数据都是一致的。而事务开始的时间不同，不同事务对同一张表，同一时刻看到的数据可能是不一样的。

InnoDB 实现的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现。一个保存了行的创建版本号（系统版本号，system version number），一个保存了行的过期（或删除）版本号。每开始一个事务，系统版本号会自动递增。事务开始时的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号作比较。对于不同的命令，MVCC 的实现描述如下：

命令	操作
select	a. 只查找版本早于（小于或等于）当前事务版本的数据行。b. 行的删除版本未定义或者大于当前事务版本号
insert	为新插入的每一行保存当前版本号作为版本号
delete	为删除的每一行保存当前版本号作为删除标识
update	插入新的一行，保存当前系统版本号作为版本号；同时将当前系统版本号保存到原来的行作为删除标识
MVCC 只在可重复读（REPEATABLE READ）、提交读（READ COMMITTED）两个隔离级别下工作。因为 未提交读（READ UNCOMMITTED）总是读取最新的数据行，而不是符合当前事务版本的数据行；可串行化（SERIALIZABLE）则会对所有读取的行都加锁。

MVCC 多出的两列使得很多数据操作不用上锁，提升了性能；不足之处是需要额外的存储空间。

InnoDB 概览：
InnoDB 是 MySQL 的默认事务型存储引擎，也是最重要、使用最广泛的存储引擎。通过间隙锁使得 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入，从而防止幻读。

一般情况下，都应该使用 InnoDB 存储引擎，除非需要用到某些 InnoDB 不具备的特性。另外，不要混合使用多种存储引擎。对存储引擎的选择，可以考虑以下几个因素：事务、备份、崩溃恢复、特有的特性。当然，还要根据具体的使用场景决定使用何种存储引擎。InnoDB 对于 95% 以上的用户都是最佳选择。

三种可以转换表的存储引擎的方法：Alter Table、导出与导入、创建与查询。

第一章主要从整体层面上讲了关于 MySQL 数据库的各个方面，这也是我第一次系统地学习 MySQL，很有收获。





第二章 基准测试

基准测试 不是压力测试
基准测试给与的是相对真实的压力，真实压力是不可预期且变化多端的。

测试指标：
吞吐量： 单位时间内的事件处理数量（TPS）
响应时间或延迟： 整体请求的响应延迟情况。
并发性： 
1. 连接数不等同于并发数
2. 单纯的并发数据没有意义。
3. 主要用于测试在不同并发的情况下 对吞吐量 延迟的影响。
4. 可扩展性

测试工具：
ab ： http 测试工具
percona MySQL Tool

第四章 数据类型
选择正确的数据类型对于获得高性能至关重要，几个原则：

更小的通常更好：尽量选择能正确存储数据的最小数据类型。
简单就好：简单数据类型的操作通常需要更小的数据周期。例如，整型优于字符串，使用整型而非字符串来存储 ip。
尽量避免 NULL：NULL 使得索引、索引统计、值比较都比较复杂；需要更多的存储空间；需要特殊处理。

设计表的时候有一些陷阱要避免：

太多的列。
太多的关联。单个查询最好在 12 个表以内做关联。
全能的枚举。防止过度使用枚举。
变相的枚举。
非此发明的 NULL。避免使用 NULL，但也不要走极端。

范式和反范式：

在范式化的数据库中，每个事实数据都会出现并且只出现一次，相反，在反范式化的数据中，信息是冗余的，可能会存储在多个地方。

范式化的好处：

- 范式化的更新操作通常比反范式化要快。
- 当数据较好地范式化时，只有很少或者没有重复数据，所以只需要修改更少的数据。
- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
- 很少有多余的数据意味着检索列表数据时更少需要 DISTINCT 或者 GROUP BY 语句。

范式化的缺点：

- 范式化设计的 schema 的缺点是通常需要关联。
- 范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。

反范式的优点：

- 数据通常在一张表中，可以很好地避免关联。
- 单独的表也能使用更有效的索引策略。
- 真实世界中，经常混用范式化和反范式化设计。最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。实现上可以使用触发器更新缓存值，例如需要统计每个用户发了多少条消息，可以在 user 表中建一个 num_messages 列，每当用户发送消息时更新这个值。


缓存表和汇总表：

为了提升读查询的速度，经常会需要一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法虽然会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变慢了，同时还增加了读操作和写操作的开发难度，但是显著地提高了读操作的性能。

当重建汇总表和缓存表时，通常需要保证数据在操作时依然可用。这就需要通过使用“影子表”来实现，“影子表”指的是一张在真实表“背后”创建的表。当完成了建表操作后，可以通过一个原子的重命名操作切换影子表和原表。

物化视图：

MySQL 不原生支持雾化视图。
使用Flexviews可以支持物化视图。


第五章 创建高性能的索引

MySQL 支持 B-Tree 索引、哈希索引、空间数据索引（R-Tree）、全文索引。

B-Tree 索引：

B-Tree 索引使用 B-Tree 数据结构来存储数据。很多存储引擎，包括 InnoDB 使用的是 B+Tree。

B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。支持：全值匹配、匹配最左前缀、匹配列前缀、匹配范围值、精确匹配某一列并范围匹配另一列、只访问索引的查询。

B-Tree 索引也有一些限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引。
- 不能跳过索引中的列。
- 如果某个查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

B+-Tree 与 B-Tree 的区别在于：
- 非叶子节点不保存数据，只保存指针。
- 叶子节点是一个链表的结构，方便范围查询

哈希索引：

在 MySQL 中，只有 Memory 引擎显式支持哈希索引。

全文索引

全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。

索引的优点：

- 索引大大减少了服务器需要扫描的数据量。
- 索引可以帮助服务器避免排序和临时表。
- 索引可以将随机 IO 变为顺序 IO。

当然，索引也并不总是最好的工具。只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。非常小的表，大部分直接全表扫描更有效；中到大型的表，索引非常有效。特大型的表，则建立和使用索引的代价将随之增长，需要一种技术可以区分出查询需要的一组数据，如分区技术。


高性能索引的策略：

正确地创建和使用索引是实现高性能查询的基础。下面是一些如何高效使用索引的方式：

- 独立的列
索引列不能是表达式的一部分，也不能是函数的参数。

- 前缀索引和索引选择性
通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。索引的选择性越高则查询效率越高，因为可以在查找时过滤掉更多的行。唯一索引的选择性是 1，性能最好。

一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度。

前缀越长，选择性越高。同时又不能太长，以便节约空间。选择的诀窍就是前缀的基数应该接近于完整列的基数。

- 多列索引
如果在 EXPLAIN 中看到有索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的。

- 选择合适的索引列顺序

- 聚簇索引(MySQL的 主键)
数据是直接保存在聚簇索引 中的。

- 主键有序插入
在高并发的情况下可能会发生主键上界的争夺
将 innodb_autoinc_lock_mode = 1
mysql可以一次生成几个连续的值。

- 覆盖索引

如果一个索引包含（或者说是覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。


第六章 查询性能优化


查询的生命周期大致可以按照顺序来看：客户端 -> 服务器 -> 服务器解析 -> 生成执行计划 -> 执行 -> 返回结果给客户端。其中执行是最重要的阶段，包括大量为了检索数据到存储引擎的调用及调用后的数据处理，包括排序、分组等。

查询需要在这些不同的地方花费时间：网络、CPU 计算、生成统计信息和执行计划、锁等待、内存、IO 等。

如果把查询看成一个任务，由一系列子任务组成。优化查询，实际上就是要优化其子任务，要么消除一些子任务，要么减少子任务的执行次数，要么让子任务运行地更快。

查询性能低下最基本的原因是访问的数据太多，大部分性能低下的查询可以通过减少访问的数据量的方式进行优化。对于低效的查询，可以通过如下两个步骤进行分析：

- 确认应用程序是否在检索大量超过需要的数据。通常是访问了太多的行或列。
- 确认 MySQL 服务层是否在分析大量超过需要的数据行。

对于 MySQL，最简单的衡量查询开销的三个指标：响应时间、扫描的行数、返回的行数。

优化有问题的查询时，可以将查询转换一种写法让其返回一样的结果。例如：

一个复杂查询分成多个简单查询。
切分查询。
很多查询优化工作实际上就是遵循一些原则让优化器能够按照预想的合理的方式运行。


优化特定类型的查询：

优化 COUNT() 查询
它有两个不同的作用：统计某个列值的数量、统计行数。注意：COUNT(*) 并不会扩展成所有的列，相反，这样的写法更清晰。
可用使用近似值、增加汇总表等来优化。

优化关联查询
优化子查询
优化 GROUP BY 和 DISTINCT
优化 LIMIT 分页
